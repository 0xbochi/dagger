---
slug: /1247/dagger-fs
displayed_sidebar: "0.2"
---

# Dagger.#FS

Filesystems are one of the building blocks of the Dagger platform. They are represented by the `dagger.#FS` type:

```cue
// A reference to a filesystem tree.
// For example:
//  - The root filesystem of a container
//  - A source code repository
//  - A directory containing binary artifacts
// Rule of thumb: if it fits in a tar archive, it fits in a #FS.
#FS: {
    $dagger: fs: _id: string | null
}
```

In Dagger, as commented above, an `#FS` is a reference to a filesystem tree: a directory storing files in a hierarchical/tree structure.

## Filesystems are omnipresent

Inside any CI pipeline and with Dagger actions in our case, filesystems are omnipresent. CI pipelines, at their core, are just a series of transformations applied on filesystems until deployment. You may, for example:

- edit code
- compile binaries
- run unit/integration tests
- deploy code
- do anything that can possibly be done with a container

Each of these use case necessit a transfer of data from one action to another. This unit of measure ? The `dagger.#FS`.

### docker.#Image / dagger.#FS / Artifacts

Differentiating between filesystems, container images and understanding how a filesystem relates to an action is a prerequisite to fully benefit from the powers of Dagger.

#### Dagger's core API

Dagger leverages, at its core, a low level API to interact with filesystem trees [(see reference)](https://docs.dagger.io/1222/core-actions-reference/#core-actions-related-to-filesystem-trees). Every other universe package is just an abstraction on top of these low-level `core` primitives.

Let's dissect one:

```cue
// Create one or multiple directory in a container
#Mkdir: {
    $dagger: task: _name: "Mkdir"

    // Container filesystem
    input: dagger.#FS

    // Path of the directory to create
    // It can be nested (e.g : "/foo" or "/foo/bar")
    path: string

    // Permissions of the directory
    permissions: *0o755 | int

    // If set, it creates parents' directory if they do not exist
    parents: *true | false

    // Modified filesystem
    output: dagger.#FS @dagger(generated)
}
```

`core.#Mkdir` is the dagger equivalent of the `mkdir` command: it takes as `input` a `dagger.#FS` and retrieves a `dagger.#FS` containing the newly created folders.

As Dagger is statically typed, leveraging the type system to understand the expectations of each action is recommended. In most cases, an action will either take as input a `dagger.#FS` or a `docker.#Image`.

#### Dissecting `docker.#Image`

Inspecting the `docker.#Image` package is a good way to grasp the relation between filesystems and images:

```cue
// A container image
#Image: {
    // Root filesystem of the image.
    rootfs: dagger.#FS

    // Image config
    config: core.#ImageConfig
}
```

Most of universe packages don't accept filesystems as `input`, and rely on images instead, to let users specify the environment in which an action's logic will be executed.

`docker.#Image` and `dagger.#FS`  are really tied, as an image is just a filesystem with some configurations on top:

```cue

// Container image config. See [OCI](https://www.opencontainers.org/).
#ImageConfig: {
    user?: string
    expose?: [string]: {}
    env?: [string]: string
    entrypoint?: [...string]
    cmd?: [...string]
    volume?: [string]: {}
    workdir?: string
    label?: [string]: string
    stopsignal?:  string
    healthcheck?: #HealthCheck
    argsescaped?: bool
    onbuild?: [...string]
    stoptimeout?: int
    shell?: [...string]
}
```

The docker package implements a `#Scratch` image by relying on the `dagger.#Scratch` type. `dagger.#Scratch` is a core type representing a minimal rootfs to have a working image.

```cue
#Scratch: #Image & {
    rootfs: dagger.#Scratch
    config: {}
}
```

As a `docker.#Image` contains a `rootfs` field, it is possible to access the `dagger.#FS` of any `docker.#Image`. It is very useful when piping actions in a pipeline.

The corollary is also true: from a given filesystem, building a `docker.#Image` is possible (with the help of the `dagger.#Scratch` type and some `core` actions).

[To learn more about the docker package](../guides/concepts/1244-docker.md)

#### Artifacts

As most of universe packages run inside containers, the execution logic of a given action sometimes creates outputs. These outputs are called artifacts, and represent files/binaries/filesystems generated by your action, and are, in general, mandatory to the plan execution.

These artifacts live inside the `rootfs`, thus are accessible and can be shared between actions.

## Transfer of filesystems between actions

Let's explore, in-depth, how to transfer filesystems between actions.

### Topology of a Universe action (from an `#FS` perspective)

As stated above, most of actions require a `docker.#Image` as `input`. As an image contains a `rootfs`, the first `#FS` of an action is its `rootfs`. As some actions create artifacts, these computed outputs are a second type of filesystem living inside the `rootfs`.

![universe action topology](/img/core-concepts/fs/universe-action-topology.png)

Lastly, some filesystems need to be shared between actions, and only need to live during the lifetime of its execution logic.
This is the last type of filesystem that you might encounter: for the sake of the guide, let's call them `additional filesystems`.

### Transfer of filesystems via `docker.#Image`

As most of Dagger actions run within a container image, an easy way to transfer an `fs` is to make the `output` image of an action the `input` of the next one. In other words, to make the state of the `rootfs` after execution, the initial `rootfs` of my second action.

![universe action topology](/img/core-concepts/fs/fs-share-via-rootfs.png)

A common use-case is to create an action whose sole purpose is to install all the required packages/dependencies, and let the next action execute the core logic:

```cue file=../tests/core-concepts/fs/client/input_output.cue title="dagger do test --log-format plain"

```

A simplified visual representation of above plan would be:

![diagram-representing-above-bash-example](/img/core-concepts/fs/explanation-bash-example.png)

More realistically, people rely a lot on the `docker.#Build` action to create base images reused in several actions:

```cue file=../tests/core-concepts/fs/client/build_image.cue title="dagger do build --log-format plain"

```

Above plan is harder to represent with just the `#FS` point of view, as the `_build.steps` field chains actions to create a final image.

![diagram-representing-above-bash-example](/img/core-concepts/fs/explanation-docker-example.png)

The `_build` action is a good example of the superpowers of Dagger. One action abstracts complexity and creates a nice DX around a specific need: building a docker image from any compatible Dagger universe package.

[To learn more about the possibilities of the docker package](../guides/concepts/1244-docker.md)

### Transfer of `#FS` via mounts

A `mount` is way to add new filesystem layers in a container image. With mounts, an image will not only have a `rootfs`, but also as many filesystem layers as the amount of `fs` mounted.

![diagram-representing-action-with-mounts](/img/core-concepts/fs/mounts-action-mounts.png)

#### Difference between a Docker bind mount and Dagger mounts

Dagger mounts are very similar to the docker ones. The big main difference is that any script interacting with the mounted folder (inside the container) writes to its filesystem layer, and does not impact the host at all.

![diagram-representing-dagger-mount](/img/core-concepts/fs/fs-mount.png)

Whether you mount a directory from your host (using the client API), or between actions, the `mount` will only be modified in the context of an action.

However, if your script creates artifacts outside of the mounted filesystem, then it will be created inside the `rootfs` layer.

![diagram-representing-dagger-mount-script-not-interacting-with-mounted-fs](/img/core-concepts/fs/fs-mount-not-interacting.png)

#### Mounts are not shared between actions

In Dagger, as an image is only composed of a `rootfs` + a `config`, when passing the image to the next action, it looses all the mounted filesystems:

![diagram-representing-mount-loss](/img/core-concepts/fs/mount-loss-action.png)

#### Mounted FS cannot be exported

Exports in Dagger only export from a `rootfs`. As mounts do not reside inside the `rootfs` layer, but on a layer above, the information residing inside a mounted filesystem gets lost, unless you mount it again inside the next action.

#### Mounts can overshadow filesystems

When mounting filesystems on top of a preexisting directory, it gets overwritten.

![diagram-representing-mount-loss](/img/core-concepts/fs/mount-overwrite.png)

In above example, the script only has access to the `/foo` and `/bar` directories that were mounted, as the artifacts present in the `rootfs` layer have been overwritten in the superposition of all layers.

#### Example

Below is a plan showing how to mount an FS prior executing a command on top of it:

```cue file=../tests/core-concepts/fs/mount/mount_fs.cue title="dagger do verify --log-format plain"

```

Visually, these are the underlying steps of above plan:

![diagram-representing-mount](/img/core-concepts/fs/explanation-mount-steps.png)

As mounts only live during the execution of the `verify` action, chaining outputs will not work.

It may not be obvious for now, but mounts are very useful to retrieve filesystems from several previous actions, as the only limitation of filesystem mounts is the amount of keys/IDs possible.

### Transfer of `#FS` via `docker.#Copy`

The aim of this action is to copy the content of an `fs` to a `rootfs`. It relies on the `core.#Copy` action to perform this operation:

```cue
// Copy files from one FS tree to another
#Copy: {
    $dagger: task: _name: "Copy"
    // Input of the operation
    input: dagger.#FS
    // Contents to copy
    contents: dagger.#FS
    // Source path (optional)
    source: string | *"/"
    // Destination path (optional)
    dest: string | *"/"
    // Optionally include certain files
    include: [...string]
    // Optionally exclude certain files
    exclude: [...string]
    // Output of the operation
    output: dagger.#FS @dagger(generated)
}
```

Let's take the same plan as the one used to previously show how to `mount` a `dagger.#FS`. In this example, we will rely on the `docker.#Copy` instead of the mount:

```cue file=../tests/core-concepts/fs/copy/copy_fs.cue title="dagger do verify --log-format plain"

```

Visually, these are the underlying steps of above plan:

![diagram-representing-copy](/img/core-concepts/fs/explanation-copy-steps.png)

The `verify` action does not have any mount, and instead has access to the `/target` artifact from the `exec` action due to the `docker.#Copy` (`_copy` action).

## Mounting host `#FS` to container (`#FS` perspective)

Filesystems are not just shared between actions, they can also be shared between the host and the Dagger runtime:

![dagger client api](/img/core-concepts/fs/dagger-client-api-fs.png)

### Example plan to read an `#FS` from the host

Below is a plan showing how to list the content of the current directory from which the dagger plan is being run (relative to the dagger CLI)

```cue file=../tests/core-concepts/fs/client/read_fs.cue title="dagger do list --log-format plain"

```

A simplified visual representation of above plan would be:

![dagger action](/img/core-concepts/fs/read_fs.png)

### Example plan to write an `#FS` to the host

Let's now write to the host filesystem:

```cue file=../tests/core-concepts/fs/client/write_fs.cue title="dagger do create --log-format plain"

```

A simplified visual representation of above plan would be:

![dagger action](/img/core-concepts/fs/write_fs.png)

[More informations regarding the client API](./1203-client.md)
