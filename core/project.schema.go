package core

import (
	"context"
	"fmt"
	"sync"

	"github.com/pkg/errors"
	"go.dagger.io/dagger/core/filesystem"
	"go.dagger.io/dagger/project"
	"go.dagger.io/dagger/router"
)

var _ router.ExecutableSchema = &projectSchema{}

type projectSchema struct {
	*baseSchema
	projectStates map[string]*project.State
	mu            sync.RWMutex
}

func (s *projectSchema) Name() string {
	return "project"
}

func (s *projectSchema) Schema() string {
	return `
"A set of scripts and/or extensions"
type Project {
	"name of the project"
	name: String!

	"schema provided by the project"
	schema: String

	"extensions in this project"
	extensions: [Extension!]

	"scripts in this project"
	scripts: [Script!]

	"other projects with schema this project depends on"
	dependencies: [Project!]

	"install the project's schema"
	install: Boolean!

	"Code files generated by the SDKs in the project"
	generatedCode: Filesystem!
}

"A schema extension provided by a project"
type Extension {
	"path to the extension's code within the project's filesystem"
	path: String!

	"schema contributed to the project by this extension"
	schema: String!

	"sdk used to generate code for and/or execute this extension"
	sdk: String!
}

"An executable script that uses the project's dependencies and/or extensions"
type Script {
	"path to the script's code within the project's filesystem"
	path: String!

	"sdk used to generate code for and/or execute this script"
	sdk: String!
}

extend type Filesystem {
	"load a project's metadata"
	loadProject(configPath: String!): Project!
}

extend type Core {
	"Look up a project by name"
	project(name: String!): Project!
}
`
}

func (s *projectSchema) Resolvers() router.Resolvers {
	return router.Resolvers{
		"Filesystem": router.ObjectResolver{
			"loadProject": router.ToResolver(s.loadProject),
		},
		"Core": router.ObjectResolver{
			"project": router.ToResolver(s.project),
		},
		"Project": router.ObjectResolver{
			"schema":        router.ToResolver(s.schema),
			"extensions":    router.ToResolver(s.extensions),
			"scripts":       router.ToResolver(s.scripts),
			"dependencies":  router.ToResolver(s.dependencies),
			"install":       router.ToResolver(s.install),
			"generatedCode": router.ErrResolver(errors.New("not implemented")),
		},
	}
}

func (s *projectSchema) Dependencies() []router.ExecutableSchema {
	return nil
}

type Project struct {
	Name string
}

type loadProjectArgs struct {
	ConfigPath string
}

func (s *projectSchema) loadProject(ctx *router.Context, parent *filesystem.Filesystem, args loadProjectArgs) (*Project, error) {
	projectState, err := project.Load(ctx, parent, args.ConfigPath, s.projectStates, &s.mu, s.gw)
	if err != nil {
		return nil, err
	}
	return &Project{Name: projectState.Name()}, nil
}

type projectArgs struct {
	Name string
}

func (s *projectSchema) project(ctx *router.Context, parent struct{}, args projectArgs) (*Project, error) {
	_, ok := s.getProjectState(args.Name)
	if !ok {
		return nil, fmt.Errorf("project %q not found", args.Name)
	}
	return &Project{Name: args.Name}, nil

	/* TODO:
	if args.Name == (&coreSchema{}).Name() {
		coreSchema := s.router.Get(args.Name)
		return &Project{
			Name:   "core",
			Schema: coreSchema.Schema(),
		}, nil
	}
	*/
}

func (s *projectSchema) schema(ctx *router.Context, parent *Project, args any) (string, error) {
	projectState, ok := s.getProjectState(parent.Name)
	if !ok {
		return "", fmt.Errorf("project %q not found", parent.Name)
	}
	return projectState.Schema(ctx, s.gw, s.platform, s.sshAuthSockID)
}

func (s *projectSchema) extensions(ctx *router.Context, parent *Project, args any) ([]*project.Extension, error) {
	projectState, ok := s.getProjectState(parent.Name)
	if !ok {
		return nil, fmt.Errorf("project %q not found", parent.Name)
	}
	return projectState.Extensions(ctx, s.gw, s.platform, s.sshAuthSockID)
}

func (s *projectSchema) scripts(ctx *router.Context, parent *Project, args any) ([]*project.Script, error) {
	projectState, ok := s.getProjectState(parent.Name)
	if !ok {
		return nil, fmt.Errorf("project %q not found", parent.Name)
	}
	return projectState.Scripts(), nil
}

func (s *projectSchema) dependencies(ctx *router.Context, parent *Project, args any) ([]*Project, error) {
	projectState, ok := s.getProjectState(parent.Name)
	if !ok {
		return nil, fmt.Errorf("project %q not found", parent.Name)
	}

	dependencies, err := projectState.Dependencies(ctx, s.projectStates, &s.mu, s.gw, s.platform, s.sshAuthSockID)
	if err != nil {
		return nil, err
	}
	depProjects := make([]*Project, len(dependencies))
	for i, dependency := range dependencies {
		if _, ok := s.projectStates[dependency.Name()]; !ok {
			s.projectStates[dependency.Name()] = dependency
		}
		depProjects[i] = &Project{Name: dependency.Name()}
	}
	return depProjects, nil
}

func (s *projectSchema) install(ctx *router.Context, parent *Project, args any) (bool, error) {
	projectState, ok := s.getProjectState(parent.Name)
	if !ok {
		return false, fmt.Errorf("project %q not found", parent.Name)
	}

	executableSchema, err := s.projectToExecutableSchema(ctx, projectState)
	if err != nil {
		return false, err
	}

	if err := s.router.Add(executableSchema); err != nil {
		return false, err
	}

	return true, nil
}

func (s *projectSchema) getProjectState(name string) (*project.State, bool) {
	s.mu.RLock()
	defer s.mu.RUnlock()
	projectState, ok := s.projectStates[name]
	return projectState, ok
}

func (s *projectSchema) projectToExecutableSchema(ctx context.Context, projectState *project.State) (router.ExecutableSchema, error) {
	schema, err := projectState.Schema(ctx, s.gw, s.platform, s.sshAuthSockID)
	if err != nil {
		return nil, err
	}

	resolvers, err := projectState.Resolvers(ctx, s.gw, s.platform, s.sshAuthSockID)
	if err != nil {
		return nil, err
	}

	params := router.StaticSchemaParams{
		Name:      projectState.Name(),
		Schema:    schema,
		Resolvers: resolvers,
	}

	dependencies, err := projectState.Dependencies(ctx, s.projectStates, &s.mu, s.gw, s.platform, s.sshAuthSockID)
	if err != nil {
		return nil, err
	}
	// TODO:(sipsma) guard against circular dependencies, dedupe objects
	for _, dependency := range dependencies {
		remoteSchema, err := s.projectToExecutableSchema(ctx, dependency)
		if err != nil {
			return nil, err
		}
		params.Dependencies = append(params.Dependencies, remoteSchema)
	}

	return router.StaticSchema(params), nil
}
